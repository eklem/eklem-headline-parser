{"version":3,"sources":["webpack://ehp/./index.js","webpack://ehp/webpack/bootstrap","webpack://ehp/webpack/startup"],"names":["findExistingWord","array","attr","value","k","length","compareObjects","a","b","count","module","exports","findKeywords","headline","body","cutoff","Set","keywordsCount","keywords","i","j","existing","wordObj","word","push","sort","l","slice","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__"],"mappings":"gCAAA,MAwCMA,EAAmB,SAAUC,EAAOC,EAAMC,GAC9C,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAMI,OAAQD,GAAK,EACrC,GAAIH,EAAMG,GAAGF,KAAUC,EACrB,OAAOC,EAGX,OAAQ,GAGJE,EAAiB,SAAUC,EAAGC,GAClC,OAAID,EAAEE,MAAQD,EAAEC,OACN,EAENF,EAAEE,MAAQD,EAAEC,MACP,EAEF,GAGTC,EAAOC,QAAU,CACfC,aA5DmB,SAAUC,EAAUC,EAAMC,EAAS,GAEtDF,EAAW,IAAI,IAAIG,IAAIH,IAGvB,MAAMI,EAAgB,GAEtB,IAAIC,EAAW,GAGf,IAAK,IAAIC,EAAI,EAAGA,EAAIN,EAASR,OAAQc,IACnC,IAAK,IAAIC,EAAI,EAAGA,EAAIN,EAAKT,OAAQe,IAE/B,GAAIP,EAASM,KAAOL,EAAKM,GAAI,CAE3B,MAAMC,EAAWrB,EAAiBiB,EAAe,OAAQJ,EAASM,IAClE,GAAIE,GAAY,EACdJ,EAAcI,GAAUZ,YACnB,CAEL,MAAMa,EAAU,CAAEC,KAAMV,EAASM,GAAIV,MAAO,GAC5CQ,EAAcO,KAAKF,IAO3BL,EAAcQ,KAAKnB,GAEnB,IAAK,IAAIoB,EAAI,EAAGA,EAAIT,EAAcZ,OAAQqB,IACxCR,EAASM,KAAKP,EAAcS,GAAGH,MAMjC,OAHIR,EAAS,IACXG,EAAWA,EAASS,MAAM,EAAGZ,IAExBG,MCpCLU,EAA2B,GCE/B,ODCA,SAASC,EAAoBC,GAE5B,GAAGF,EAAyBE,GAC3B,OAAOF,EAAyBE,GAAUnB,QAG3C,IAAID,EAASkB,EAAyBE,GAAY,CAGjDnB,QAAS,IAOV,OAHAoB,EAAoBD,GAAUpB,EAAQA,EAAOC,QAASkB,GAG/CnB,EAAOC,QCjBRkB,CAAoB,K","file":"headline-parser.js","sourcesContent":["const findKeywords = function (headline, body, cutoff = 0) {\n  // remove duplicates in headline\n  headline = [...new Set(headline)]\n\n  // keywords array of word objects with word count\n  const keywordsCount = []\n  // returned array (cutoff if != 0)\n  let keywords = []\n\n  // loop through headline and body\n  for (var i = 0; i < headline.length; i++) {\n    for (var j = 0; j < body.length; j++) {\n      // headline/body mathching\n      if (headline[i] === body[j]) {\n        // check if word exists in keywordsCount first and update it\n        const existing = findExistingWord(keywordsCount, 'word', headline[i])\n        if (existing > -1) {\n          keywordsCount[existing].count++\n        } else {\n          // create object and push to array\n          const wordObj = { word: headline[i], count: 1 }\n          keywordsCount.push(wordObj)\n        }\n      }\n    }\n  }\n\n  // Sort on most times used in body\n  keywordsCount.sort(compareObjects)\n  // loop through keywordsCount and push word to keywords\n  for (let l = 0; l < keywordsCount.length; l++) {\n    keywords.push(keywordsCount[l].word)\n  }\n  // slice, if cutoff set\n  if (cutoff > 0) {\n    keywords = keywords.slice(0, cutoff)\n  }\n  return keywords\n}\n\nconst findExistingWord = function (array, attr, value) {\n  for (var k = 0; k < array.length; k += 1) {\n    if (array[k][attr] === value) {\n      return k\n    }\n  }\n  return -1\n}\n\nconst compareObjects = function (a, b) {\n  if (a.count > b.count) {\n    return -1\n  }\n  if (a.count < b.count) {\n    return 1\n  }\n  return 0\n}\n\nmodule.exports = {\n  findKeywords: findKeywords\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(10);\n"],"sourceRoot":""}